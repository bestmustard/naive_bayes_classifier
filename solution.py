from bnetbase import Variable, Factor, BN  
import csv  

def multiply_factors(Factors):
    '''Factors is a list of factor objects. 
    Return a new factor that is the product of the factors in Factors. 
    @return a factor'''   
    scope = set()
    for factor in Factors:
        scope.update(factor.get_scope())
        
    product_scope = list(scope)
    product = Factor("product", product_scope)
    assignments = [{}]
    for var in product_scope:
        new_assignments = []
        for value in var.domain():
            for assignment in assignments:
                new_assignment = assignment.copy()
                new_assignment[var] = value
                new_assignments.append(new_assignment)
        assignments = new_assignments
    for assignment in assignments:
        temp = 1.0
        for factor in Factors:
            for var, val in assignment.items():
                if var in factor.get_scope():
                    var.set_assignment(val)
            temp *= factor.get_value_at_current_assignments()
        product.add_value_at_current_assignment(temp)
    return product


def restrict_factor(f, var, value):
    '''f is a factor, var is a Variable, and value is a value from var.domain. 
    Return a new factor that is the restriction of f by this var = value. 
    Don't change f! If f has only one variable its restriction yields a 
    constant factor. 
    @return a factor'''
    scope = [v for v in f.get_scope() if v != var]
    factor = Factor(f.name + "restrict", scope)

    def find_all(vars):
        if not vars:
            return [[]]
        curr = vars[0]
        holder = []
        for other in find_all(vars[1:]):
            for value in curr.domain():
                holder.append([value] + other)
        return holder

    for assignments in find_all(scope):
        full_assignments = {v: a for v, a in zip(scope, assignments)}
        full_assignments[var] = value
        for v, a in full_assignments.items():
            v.set_assignment(a)
        factor.add_value_at_current_assignment(f.get_value_at_current_assignments())

    return factor


def sum_out_variable(f, var):
    '''f is a factor, var is a Variable. 
    Return a new factor that is the result of summing var out of f, by summing 
    the function generated by the product over all values of var. 
    @return a factor'''     
    scope = []
    for v in f.get_scope():
        if v != var:
            scope.append(v)

    factor = Factor("sum_out" + f.name, scope)
    def find_all(vars):
        if not vars:
            return [[]]
        holder = []
        current_var = vars[0]
        for value in current_var.domain():
            for other in find_all(vars[1:]):
                holder.append([value] + other)
        return holder

    for new_assignments in find_all(scope):
        total = 0
        for val in var.domain():
            for v, a in zip(scope, new_assignments):
                v.set_assignment(a)
            var.set_assignment(val)
            curr = f.get_value_at_current_assignments()
            total += curr
        factor.add_value_at_current_assignment(total)
    return factor


def normalize(nums):
    '''nums is a list of numbers. Return a new list of numbers where the new 
    numbers sum to 1, i.e., normalize the input numbers. 
    @return a normalized list of numbers'''
    total = sum(nums)
    if total == 0:
        return 0
    return [num/total for num in nums]


def VE(Net, QueryVar, EvidenceVars):
    """
    Input: Net---a BN object (a Bayes Net) 
           QueryVar---a Variable object (the variable whose distribution 
                      we want to compute) 
           EvidenceVars---a LIST of Variable objects. Each of these 
                          variables has had its evidence set to a particular 
                          value from its domain using set_evidence. 
     VE returns a distribution over the values of QueryVar, i.e., a list 
     of numbers, one for every value in QueryVar's domain. These numbers 
     sum to one, and the i'th number is the probability that QueryVar is 
     equal to its i'th value given the setting of the evidence 
     variables. For example if QueryVar = A with Dom[A] = ['a', 'b', 
     'c'], EvidenceVars = [B, C], and we have previously called 
     B.set_evidence(1) and C.set_evidence('c'), then VE would return a 
     list of three numbers. E.g. [0.5, 0.24, 0.26]. These numbers would 
     mean that Pr(A='a'|B=1, C='c') = 0.5 Pr(A='a'|B=1, C='c') = 0.24 
     Pr(A='a'|B=1, C='c') = 0.26 
     @return a list of probabilities, one for each item in the domain of the QueryVar 
     """ 
    factors = Net.factors()[:]
    for var in EvidenceVars:
        val = var.get_evidence()
        new_factors = []
        for factor in factors:
            if var in factor.get_scope():
                new_factor = restrict_factor(factor, var, val)
                new_factors.append(new_factor)
            else:
                new_factors.append(factor)
        factors = new_factors

    holder = Net.variables()[:]
    holder.remove(QueryVar)

    for var in holder:
        useful = [factor for factor in factors if var in factor.get_scope()]
        factors = [factor for factor in factors if var not in factor.get_scope()]
        if useful:
            product_factor = multiply_factors(useful)
            new_factor = sum_out_variable(product_factor, var)
            factors.append(new_factor)

    results = []
    for value in QueryVar.domain():
        results.append(multiply_factors(factors).get_value([value]))
    return normalize(results)


def NaiveBayesModel():  
    ''' 
    NaiveBayesModel returns a BN that is a Naive Bayes model that  
    represents the joint distribution of value assignments to  
    variables in the Adult Dataset from UCI.  Remember a Naive Bayes model 
    assumes P(X1, X2,.... XN, Class) can be represented as  
    P(X1|Class)*P(X2|Class)* .... *P(XN|Class)*P(Class). 
    When you generated your Bayes Net, assume that the values  
    in the Salary column of the dataset are the CLASS that we want to predict. 
    @return a BN that is a Naive Bayes model and which represents the Adult Dataset.  
    '''  
    ### READ IN THE DATA  
    input_data = []  
    with open('data/adult-train.csv', newline='') as csvfile:  
        reader = csv.reader(csvfile)  
        headers = next(reader, None) #skip header row  
        for row in reader:  
            input_data.append(row)  
  
    ### DOMAIN INFORMATION REFLECTS ORDER OF COLUMNS IN THE DATA SET  
    variable_domains = {  
    "Work": ['Not Working', 'Government', 'Private', 'Self-emp'],  
    "Education": ['<Gr12', 'HS-Graduate', 'Associate', 'Professional', 'Bachelors', 'Masters', 'Doctorate'],      
    "MaritalStatus": ['Not-Married', 'Married', 'Separated', 'Widowed'],  
    "Occupation": ['Admin', 'Military', 'Manual Labour', 'Office Labour', 'Service', 'Professional'],      
    "Relationship": ['Wife', 'Own-child', 'Husband', 'Not-in-family', 'Other-relative', 'Unmarried'],  
    "Race": ['White', 'Black', 'Asian-Pac-Islander', 'Amer-Indian-Eskimo', 'Other'],  
    "Gender": ['Male', 'Female'],  
    "Country": ['North-America', 'South-America', 'Europe', 'Asia', 'Middle-East', 'Carribean'],  
    "Salary": ['<50K', '>=50K']  
    }  
    count_sal = {'<50K': 0, '>=50K': 0}
    count_feat = {}
    for feat, values in variable_domains.items():
        if feat != 'Salary':
            count_feat[feat] = {}
            for value in values:
                count_feat[feat][value] = {'<50K': 0, '>=50K': 0}
    feats = list(variable_domains.keys())
    feats = feats[:-1]

    for row in input_data:
        sal_val = row[-1]
        count_sal[sal_val] += 1
        for i, feat in enumerate(feats): 
            feat_val = row[i]
            if feat_val in variable_domains[feat]:
                count_feat[feat][feat_val][sal_val] += 1

    total = sum(count_sal.values())

    sal_p = {}
    for k, v in count_sal.items():
        sal_p[k] = v/total

    # conditional
    cond_p = {}
    for feat, values in count_feat.items():
        cond_p[feat] = {}
        for value, count in values.items():
            cond_p[feat][value] = {}
            for sal in count_sal:
                cond_p[feat][value][sal] = count[sal]/count_sal[sal]

    vars = []
    for name, domain in variable_domains.items():
        variable = Variable(name, domain=domain)
        vars.append(variable)

    sal_factor = Factor("Salary", [vars[-1]])
    for val, p in sal_p.items():
        sal_factor.add_values([[val, p]])

    feat_factors = []
    for i, feat in enumerate(headers[:-1]):
        feat_var = vars[i]
        sal_var = vars[-1]
        factor = Factor(feat, [feat_var, sal_var])
        values = []
        for feat_val in feat_var.domain():
            for sal_val in sal_var.domain():
                p = cond_p[feat][feat_val][sal_val]
                values.append([feat_val, sal_val, p])
        factor.add_values(values)
        feat_factors.append(factor)

    return BN("Adult Dataset", vars, [sal_factor] + feat_factors)


def Explore(Net, q):
    '''    Input: Net---a BN object (a Bayes Net) 
           question---an integer indicating the question in HW4 to be calculated. Options are: 
           1. What percentage of the women in the data set end up with a P(S=">=$50K"|E1) that is strictly greater than P(S=">=$50K"|E2)? 
           2. What percentage of the men in the data set end up with a P(S=">=$50K"|E1) that is strictly greater than P(S=">=$50K"|E2)? 
           3. What percentage of the women in the data set with P(S=">=$50K"|E1) > 0.5 actually have a salary over $50K? 
           4. What percentage of the men in the data set with P(S=">=$50K"|E1) > 0.5 actually have a salary over $50K? 
           5. What percentage of the women in the data set are assigned a P(Salary=">=$50K"|E1) > 0.5, overall? 
           6. What percentage of the men in the data set are assigned a P(Salary=">=$50K"|E1) > 0.5, overall? 
           @return a percentage (between 0 and 100) 
    '''
    test_data = []
    with open('data/adult-test.csv', newline='') as csvfile:
        reader = csv.reader(csvfile)
        next(reader, None)  # skip header
        for row in reader:
            test_data.append(row)

    sal_var = Net.get_variable("Salary")
    count = 0
    relevant = 0
    count_E1_gt_E2 = 0

    for row in test_data:
        gender = row[6]
        actual_sal = row[-1]

        E1 = {"Work": row[0], "Occupation": row[3], "Education": row[1], "Relationship": row[4]}
        E2 = {"Work": row[0], "Occupation": row[3], "Education": row[1], "Relationship": row[4], "Gender": gender}

        evidence_E1 = []

        for var_name, value in E1.items():
            var = Net.get_variable(var_name)
            var.set_evidence(value)
            evidence_E1.append(var)

        evidence_E2 = []
        for var_name, value in E2.items():
            var = Net.get_variable(var_name)
            var.set_evidence(value)
            evidence_E2.append(var)

        p_E1 = VE(Net, sal_var, evidence_E1)[sal_var.domain().index('>=50K')]
        p_E2 = VE(Net, sal_var, evidence_E2)[sal_var.domain().index('>=50K')]

        if q in [1, 2]:
            if (q == 1 and gender == 'Female') or (q == 2 and gender == 'Male'):
                if p_E1 > p_E2:
                    count_E1_gt_E2 += 1
                relevant += 1
        elif q in [3, 4]:
            if (q == 3 and gender != 'Female') or (q == 4 and gender != 'Male'):
                continue
            if p_E1 > 0.5:
                relevant += 1
                if actual_sal == '>=50K':
                    count += 1
        elif q in [5, 6]:
            if (q == 5 and gender != 'Female') or (q == 6 and gender != 'Male'):
                continue
            if p_E1 > 0.5:
                count += 1
            relevant += 1

    if relevant == 0: 
        return 0
    if q in [1, 2]:
        p = (count_E1_gt_E2/relevant) * 100
    else:
        p = (count/relevant) * 100
    return p
